N=6
dT=1
sigma=matrix(0.01,N,N)
f0=c(rep(0.05,N))
maturity=10

#discount factor updating
update_DF<-function(ft,dT,N,DFt,t){

  for( i in (t+1):(N+1) ){ DFt[i] <- DFt[i-1]/(1+dT*ft[i-1])}
  return(DFt)
}
#drift term calculation
drift_calc<-function(ft,dT,N,tdrift,sigma,t){
  
  #for the final year the for loop bounds switch   so this is needed to catch it
  if(t+1==N){
    return(-tdrift)
  }
  for( i in (N-1):(t+1) ){ tdrift[i] <- (tdrift[i+1]+(dT*sigma[i])/(1+dT*ft[i+1]))}
  return(-tdrift)
}
#method that pushes forward using euler discretisation 
dfi_calc<-function(ft,dT,N,tdrift,sigma,t){
  (ft+tdrift*sigma+sigma*rnorm(1))
}
#demonstration function
Demo<- function(f0,dT,N,sigma){
  #set matrices
  LIBOR=matrix(NA,N,N)
  drift=matrix(NA,N,N)
  DF=matrix(NA,N+1,N)
  #Starting State
  LIBOR[,1]=f0
  #diagonal of df=1
  diag(DF)<-1
  #drift of TN=0 as it is the measure we use.
  drift[N,c(2:N)]=0
  
  DF[,1]=update_DF(LIBOR[,1],dT,N,DF[,1],1)
  for(i in 2:N){
    drift[,i]=drift_calc(LIBOR[,i-1],dT,N,drift[,i],sigma[,i-1],i-1)
    LIBOR[,i]=dfi_calc(LIBOR[,i-1],dT,N,drift[,i],sigma[,i-1],i-1)
    DF[,i]=update_DF(LIBOR[,i],dT,N,DF[,i],i)
  }
  return(list("LIBOR" = LIBOR, "DF" = DF,"Drift"=drift))
}
#function that runs one bond pricing monte carlo
Monte_Carlo_LIBOR_bond<- function(f0,dT,N,sigma){
  LIBOR=matrix(NA,N,N)
  drift=matrix(NA,N,N)
  DF=matrix(NA,N+1,N)
  #Starting State
  LIBOR[,1]=f0
  #diagonal of df=1
  diag(DF)<-1
  #drift of TN=0 as it is the measure we use.
  drift[N,c(2:N)]=0
  DF[,1]=update_DF(LIBOR[,1],dT,N,DF[,1],1)
  for(i in 2:N){
    drift[,i]=drift_calc(LIBOR[,i-1],dT,N,drift[,i],sigma[,i-1],i-1)
    LIBOR[,i]=dfi_calc(LIBOR[,i-1],dT,N,drift[,i],sigma[,i-1],i-1)
    DF[,i]=update_DF(LIBOR[,i],dT,N,DF[,i],i)
  }
  #divide by numeraire
  bonds<- append(1/DF[N+1,c(1:N)],1/1)
  #multiply by numeraire at time=0
  return(bonds*DF[N+1,1])
}
#function to calculate the results for part 1
simulate_MC_LIBOR_bond<- function(f0,dT,N,sigma,simulations){
  simulation<-(replicate(simulations,Monte_Carlo_LIBOR_bond(f0,dT,N,sigma)))
  se<-apply(simulation, MARGIN=1,sd)/sqrt(simulations)
  mean_mc=apply(simulation, MARGIN=1,mean)
  return(list("Simulations"=simulations,"MC_estimate"=mean_mc,"Initial_LIBOR"=update_DF(f0,dT,N,c(1,rep(NA,N)),1), "difference_LIBOR_MC"= update_DF(f0,dT,N,c(1,rep(NA,N)),1)-mean_mc, "StandardError"=se))
}


#swaption pricer for one chain
Monte_Carlo_Swaption<- function(f0,dT,N,sigma,K,maturity ){
 
  LIBOR=matrix(NA,N,N)
  drift=matrix(NA,N,N)
  DF=matrix(NA,N+1,N)
  #Starting State
  LIBOR[,1]=f0
  #diagonal of df=1
  diag(DF)<-1
  #drift of TN=0 as it is the measure we use.
  drift[N,c(2:N)]=0
  DF[,1]=update_DF(LIBOR[,1],dT,N,DF[,1],1)
  #indexing compensation
  maturity=maturity+1
  for(i in 2:N){
    drift[,i]=drift_calc(LIBOR[,i-1],dT,N,drift[,i],sigma[,i-1],i-1)
    LIBOR[,i]=dfi_calc(LIBOR[,i-1],dT,N,drift[,i],sigma[,i-1],i-1)
    DF[,i]=update_DF(LIBOR[,i],dT,N,DF[,i],i)
  }
  #set storage for the par rates and p
  par_rates<-c(rep(NA,length(maturity)))
  P<-c(rep(NA,length(maturity)))
  #calculate the par rates and p's
  for(i in maturity){
    P[i-1]=sum(DF[c((i+1):(N+1)),i])
    par_rates[i-1]=(1-DF[N+1,i])/P[i-1]
  }
  #calculate the payoffs for a given value of K and turn it into an easy to read format
  payoffs<-NULL
  for(j in K){
    temp= P*sapply(par_rates,function(x)max(x-j,0))/DF[N+1,maturity]
    payoffs=cbind(payoffs,temp)
  }
  colnames(payoffs)<-(K)
  rownames(payoffs)<-maturity-1
  return(payoffs*DF[N+1,1])
}

Monte_Carlo_Swaption(f0,dT,N,sigma,K,maturity)


simulate_swaption<-function(f0,dT,N,sigma,K,maturity,simulations){
  #this creates a 3 three dimensional array where the third dimension is the iteration of a simulation
  simulated=replicate(simulations,Monte_Carlo_Swaption(f0,dT,N,sigma,K,maturity))
  #extract the values of interest from all our payoff matrices
  means=apply(simulated, c(1,2), mean)
  SE=apply(simulated, c(1,2), sd)/sqrt(simulations)
  test=
  return(list("SE"=SE,"Prices"=means))
}



#calculates the price for a given maturity and range of K's
gaussian_formula<-function(f0,dT,N,sigma,K,maturity){
  #set initial term structure and calculate our supporting variables
DF0=update_DF(f0,dT,N,c(1,rep(NA,N)),1)
par=(DF0[maturity+1]-DF0[N+1])/sum(DF0[c((maturity+2):(N+1))])
d=(par-K)/(sigma*sqrt(maturity-0))
pdf=exp((-1/2)*d^2)/sqrt(2*pi)
#pricing formula that returns a vector of prices for all K
V=sum(DF0[c((maturity+2):(N+1))])*((par-K)*pnorm(d)+sigma*sqrt(maturity-0)*pdf)
return(V)
}
#function that calculates for all maturities
fullrange<-function(f0,dT,N,sigma,K,maturity){
  prices=t(as.data.frame(sapply(maturity, function(x)gaussian_formula(f0,dT,N,sigma,K,x))))
  rownames(prices)=maturity
  colnames(prices)=K
  return((prices))
}
#code that constructs the tables in the same form as the example excel for a single draw
Demo(f0,dT,N,sigma)
#simulation of the discount bonds with comparitive values based on initial libor terms
simulate_MC_LIBOR_bond(f0,dT,N,sigma,10000)
  

maturity<-c(1:5)
K<-c(0,0.01,0.02,0.03,0.04,0.05)
Monte_Carlo_Swaption(f0,dT,N,sigma,K,maturity)

mcswaption=simulate_swaption(f0,dT,N,sigma,K,maturity,1000)
gaussian_aprox=fullrange(f0,dT,N,0.01,K,maturity)
#difference between methods and mc standard error
mcswaption$Prices-gaussian_aprox
mcswaption$SE
abs(mcswaption$SE)-2*mcswaption$SE>0


call_fun <- function(s0, K, r, T, sig) {
  d1 <- (log(s0/K) + (r + sig^2/2)*T) / (sig*sqrt(T))
  d2 <- d1 - sig*sqrt(T)
  s0*pnorm(d1) - K*exp(-r*T)*pnorm(d2)
  
}
